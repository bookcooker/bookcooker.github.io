<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../css/style.css">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

    <!-- Setup theme-color -->
    <!-- start theme color meta headers -->
    <meta name="theme-color" content="#151515">
    <meta name="msapplication-navbutton-color" content="#151515">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- end theme color meta headers -->


    <!-- Setup Google Analytics -->



    <!-- You can set your favicon here -->
    <!-- link rel="shortcut icon" type="image/x-icon" href="/hacker/favicon.ico" -->

    <!-- end custom head snippets -->


    <!-- Begin Jekyll SEO tag v2.7.1 -->
    <title>bookcooker | Welcome to bookcooker.</title>
    <meta name="generator" content="Jekyll v3.9.0">
    <meta property="og:title" content="bookcooker">
    <meta property="og:locale" content="en_US">
    <meta name="description" content="a new series about blog.">
    <meta property="og:description" content="a new series about blog.">
    <link rel="canonical" href="https://github.com/bookcooker/">
    <meta property="og:url" content="https://bookcooker.github.io/">
    <meta property="og:site_name" content="bookcooker">
    <meta name="twitter:card" content="summary">
    <meta property="twitter:title" content="bookcooker">
    <script type="application/ld+json">
{"description":"a new series about blog.","url":"https://github.com/bookcooker/","@type":"WebSite","headline":"bookcooker","name":"bookcooker","@context":"https://schema.org"}</script>
</head>

<header>
    <div class="container">
        <a id="a-title" href="https://bookcooker.github.io/">
            <h1>bookcooker;</h1>
        </a>
        <h2>a new series about blog;</h2>

        <section id="downloads">

            <a href="../about.html" class="btn">About;</a>
            <a href="../tree.html" class="btn">Tree;</a>
            <a href="../sample.html" class="btn">Sample;</a>
            <a href="https://github.com/bookcooker" class="btn"> GitHub;</a>
        </section>
    </div>
</header>

<body>
    <div class="container">
        <section id="main_content">
            <h1 id="_1">第一章 计算机系统概述</h1>
<h2 id="_2">并发、共享、虚拟、异步</h2>
<p>没有并发和共享，就没有虚拟和异步</p>
<p>并发和共享互为存在条件</p>
<p>只有系统有并发性，才能导致异步性</p>
<h2 id="_3">命令接口</h2>
<p>联机：交互式</p>
<p>脱机：批处理</p>
<h2 id="_4">程序接口</h2>
<p>系统调用（广义指令）</p>
<h2 id="_5">操作系统用作扩充机器</h2>
<p>没有任何软件支持的计算机称为裸机</p>
<p>覆盖了软件的机器称为<strong>扩充机器</strong>或<strong>虚拟机</strong></p>
<h2 id="_6">操作系统发展</h2>
<p>手工操作系统：独占全机、CPU等待手工操作</p>
<p>单道批处理操作系统：解决人机矛盾、CPU和I/O设备速率不匹配、每次主机内存仅存放一道作业</p>
<p>多道批处理操作系统：资源利用率高、用户响应时间长、不提供人机交互</p>
<p>分时操作系统：同时、交互、独立、及时</p>
<p>实时操作系统：及时、可靠</p>
<p>网络操作系统</p>
<p>分布式计算机系统</p>
<p>个人操作系统</p>
<h2 id="_7">操作系统运行机制</h2>
<p>CPU的状态划分为用户态、核心态</p>
<h2 id="_8">中断和异常</h2>
<p>中断（外中断）：CPU执行指令意外的事件【设备发出的I/O结束中断】</p>
<p>异常（内中断、陷入）：CPU执行指令内部的事件【非法操作码、地址越界、算术溢出、虚拟存储系统的缺页、陷入指令】</p>
<h2 id="_9">中断处理过程</h2>
<div class="codehilite"><pre><span></span><code><span class="nf">graph</span><span class="w"> </span><span class="n">LR</span>
<span class="err">关中断</span><span class="mi">1</span><span class="o">--&gt;</span><span class="err">保存断点</span>
<span class="err">保存断点</span><span class="o">--&gt;</span><span class="err">中断服务程序寻址</span>
<span class="err">中断服务程序寻址</span><span class="o">--&gt;</span><span class="err">保存现场和屏蔽字</span>
<span class="err">保存现场和屏蔽字</span><span class="o">--&gt;</span><span class="err">开中断</span><span class="mi">1</span>
<span class="err">开中断</span><span class="mi">1</span><span class="o">--&gt;</span><span class="err">执行中断服务程序</span>
<span class="err">执行中断服务程序</span><span class="o">--&gt;</span><span class="err">关中断</span><span class="mi">2</span>
<span class="err">关中断</span><span class="mi">2</span><span class="o">--&gt;</span><span class="err">恢复现场和屏蔽字</span>
<span class="err">恢复现场和屏蔽字</span><span class="o">--&gt;</span><span class="err">开中断</span><span class="mi">2</span>
<span class="err">开中断</span><span class="mi">2</span><span class="o">--&gt;</span><span class="err">中断返回</span>
</code></pre></div>

<p><img alt="os_1" src="../images/os_1.png" /></p>
<h2 id="_10">系统调用</h2>
<p>用户程序中调用操作系统提供的子功能</p>
<p>程序员可以使用高级语言，估计又要可以调用库函数，有的库函数封装了系统调用</p>
<p>用户进程执行 调用系统调用 <strong>进入核心态</strong> 执行系统调用 <strong>退出核心态</strong> 从系统调用返回</p>
<h2 id="_11">大内核 微内核</h2>
<p>大内核：内核代码庞大、结构混乱、难以维护、提供高性能系统服务</p>
<p>微内核：分离内核与服务、频繁切换用户核心态、操作系统执行开销大、内核内容少、方便维护</p>
<h1 id="_12">第二章 进程管理</h1>
<p>进程:程序段、数据段、PCB进程控制块</p>
<p>进程映像是静态的，进程是动态的</p>
<p>动态、并发、独立、异步、结构</p>
<h2 id="_13">进程状态</h2>
<p>运行、就绪、阻塞、创建、结束</p>
<h2 id="_14">进程通信</h2>
<p>共享存储（需要同步互斥工具PV操作、低级：基于共享数据结构、高级：基于存储区）</p>
<p>消息传递（进程间数据交换以格式化消息为单位、直接/间接）</p>
<p>管道通信（pipe文件用于连接一个读进程和写进程通信、半双工、全双工需要两条管道）</p>
<h2 id="_15">线程 多线程</h2>
<p>引入进程目的：更好的使多道程序<strong>并发</strong>执行</p>
<p>引入线程目的：减小程序在并发执行付出的时空开销，提高并发性能</p>
<p>线程：线程ID、程序计数器、寄存器结合、堆栈组合、三态【就绪、阻塞、运行】</p>
<p>轻量实体，无系统资源，唯一ID和线程控制块</p>
<p>用户级线程ULT：操作系统意识不到ULT的存在，有关线程管理由应用程序完成</p>
<p>内核级线程KLT：有关线程管理由内核完成</p>
<p>多线程模型：多对一、一对一、多对多（m&lt;=n）</p>
<h2 id="_16">处理机调度</h2>
<p>调度层次：作业调度（高）、内存调度（中）、进程调度（低）</p>
<p>不能进行进程调度与切换：处理中断、进程处于内核态、其他需要完全屏蔽中断的原子操作</p>
<p>调度方式：非剥夺调度（非抢占方式、适用于大多批处理系统、不能用于分时系统和大多数的实时系统）、剥夺调度（抢占方式、有优先权、短进程优先、时间片原则）</p>
<p>调度基本原则：CPU利用率、系统吞吐量、周转时间、等待时间、响应时间</p>
<p>系统吞吐量：单位时间内CPU完成作业的数量</p>
<p>周转时间：从作业提交到作业完成所用时间</p>
<p>$$
&amp;T=t_{等待}+t_{就绪队列排队}+t_{上处理机运行及输入输出}\
&amp;t_{周转时间}=t_{作业完成时间}-t_{作业提交时间}\
&amp;t_{平均周转时间}=\frac{\sum_i^n{t_i}}{n}(作业i的周转时间：t_i)\
&amp;t_{带权周转时间}=\frac{t_{作业周转时间}}{t_{作业实际运转}}\geq{1}\
&amp;t_{带权平均周转时间}=\frac{\sum_i^n{t_i}}{n}(作业i的带权周转时间：t_i)\
$$</p>
<p>等待时间：进程处于等处理机状态的时间和</p>
<p>响应时间：从用户提交请求到系统首次产生响应所用时间</p>
<p><strong>调度算法</strong>：先来先服务（FCFS、非抢占）、短作业优先（SJF、SPF）、抢占式短作业优先（SRTN）、优先级调度、高响应比优先（HRRN）、时间片轮转调度（RR）、多级反馈队列调度</p>
<p>1.先来先服务（FCFS）：简单，效率低；对长作业有利，对短作业不利；有利于CPU繁忙型作业，不利于I/O繁忙型作业；不会导致饥饿；多用于早期批处理系统</p>
<p>2.短作业优先（SJF、SPF）：当前已到达的最短作业先上处理机；有优先权、短进程优先、时间片原则；适用于实时/分时操作系统；调度机制导致长作业长时间不被调度（饥饿）；多用于早期批处理系统</p>
<p>3.抢占式短作业优先（SRTN）：最短剩余时间算法</p>
<p>4.优先级调度：适用于实时操作系统；剥夺、非剥夺、静态优先级、动态优先级；系统进程&gt;用户进程 交互型进程&gt;非交互型进程 I/O型进程&gt;计算型进程;不导致饥饿</p>
<p>5.高响应比优先（HRRN）：多用于早期批处理系统</p>
<p>$$
&amp;响应比R_p=\frac{t_{等待时间}+t_{要求服务时间}}{t_{要求服务时间}}\geq{1}\
$$</p>
<p>6.时间片轮转调度（RR）：时间片大小设置对系统性能影响很大，时间片足够大，以至于所有进程都能在一个时间片完成，退化为先来先服务算法；时间片太小，处理机频繁在进程间切换，增加处理机开销；时间片长短由系统的响应时间、就绪队列的进程数目、系统处理能力决定；不会导致饥饿</p>
<p>7.多级反馈队列调度：设置多个就绪队列，各个队列赋予不同优先级，赋予各个队列中进程执行时间片的大小各个不同，一个进程进入内存后挂在一级队列队尾，时间片内未完成进入第二级队列队尾，第一级队列为空下一级运行；课本认为是抢占式算法；</p>
<h2 id="_17">进程同步</h2>
<p>临界资源：进入区、临界区、退出区、剩余区</p>
<p>同步：完成某种任务而建立的两个或多个进程，需要协调制约关系</p>
<p>互斥：一个进程使用临界资源另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程允许访问临界资源</p>
<p>为禁止两个进程进入同一个临界区，指定准则：</p>
<p>（1）空闲让进</p>
<p>（2）忙则等待</p>
<p>（3）有限等待</p>
<p>（4）让权等待</p>
<p>实现互斥基本方法：</p>
<p>（1）软件：单标志法（违背空闲让进）、双标志法先检查（违法忙则等待）、双标志法后检查（导致饥饿、违背空闲让进、有限等待）、皮特森算法Peterson's Algorithm（违法让权等待）</p>
<p>（2）硬件：中断屏蔽方法（禁止一切中断发生、优：简单高效 / 缺：不适用多处理机、用户进程，只适用于系统内核进程）、硬件指令方法TS/TSL（优：适用于任意数目的进程，无论是单处理机还是多处理机，简单容易验证其正确性 / 缺：不能实现让权等待，从等待中随机选择一个进临界区，可能导致饥饿）</p>
<p><strong>信号量</strong></p>
<p>整型信号量：用于表示资源数目的整型量S，只要信号量S&lt;=0，就会不断测试，违背让权等待</p>
<div class="codehilite"><pre><span></span><code><span class="n">wait</span><span class="p">(</span><span class="n">S</span><span class="p">){</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">S</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="n">S</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">signal</span><span class="p">(</span><span class="n">S</span><span class="p">){</span>
<span class="w">    </span><span class="n">S</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>记录型信号量：一个用于记录资源数目的整型量value，一个进程链表L，链接等待资源的进程,S.L解决了让权等待的问题</p>
<div class="codehilite"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">process</span><span class="w"> </span><span class="o">*</span><span class="n">L</span><span class="p">;</span>
<span class="p">}</span><span class="n">semaphore</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">wait</span><span class="p">(</span><span class="n">semaphore</span><span class="w"> </span><span class="n">S</span><span class="p">){</span>
<span class="w">    </span><span class="n">S</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">--</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">        </span><span class="n">add</span><span class="w"> </span><span class="k">this</span><span class="w"> </span><span class="n">process</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">L</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">block</span><span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">L</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">signal</span><span class="p">(</span><span class="n">semaphore</span><span class="w"> </span><span class="n">S</span><span class="p">){</span>
<span class="w">    </span><span class="n">S</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">        </span><span class="n">remove</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">process</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">L</span><span class="p">;</span>
<span class="w">        </span><span class="n">wakeup</span><span class="p">(</span><span class="n">P</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>利用信号量实现同步：前V后P，必须保证一前一后，实现同步关系</p>
<div class="codehilite"><pre><span></span><code><span class="n">semaphore</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">P1</span><span class="p">(){</span>
<span class="w">    </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">V</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
<span class="n">P2</span><span class="p">(){</span>
<span class="w">    </span><span class="n">P</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
<span class="w">    </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div>

<p>利用信号量实现互斥：</p>
<div class="codehilite"><pre><span></span><code><span class="n">seamphore</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">P1</span><span class="p">(){</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">P</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
<span class="w">    </span><span class="n">进程P1的临界区</span><span class="p">;</span>
<span class="w">    </span><span class="n">V</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
<span class="n">P2</span><span class="p">(){</span>
<span class="w">   </span><span class="p">...</span>
<span class="w">   </span><span class="n">P</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
<span class="w">   </span><span class="n">进程P2的临界区</span>
<span class="w">   </span><span class="nf">V</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
<span class="w">   </span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div>

<p>利用信号量实现前驱关系：</p>
<p>对不同的临界资源设置不同的互斥信号量，PV必须成对出现</p>
<p><img alt="OS_mutex" src="../images/OS_mutex.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="n">semaphore</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="n">S1</span><span class="p">(){</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">V</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span>
<span class="w">    </span><span class="n">V</span><span class="p">(</span><span class="n">a2</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">S2</span><span class="p">(){</span>
<span class="w">    </span><span class="n">P</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">V</span><span class="p">(</span><span class="n">b1</span><span class="p">);</span>
<span class="w">    </span><span class="n">V</span><span class="p">(</span><span class="n">b2</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">S3</span><span class="p">(){</span>
<span class="w">    </span><span class="n">P</span><span class="p">(</span><span class="n">a2</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">V</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">S4</span><span class="p">(){</span>
<span class="w">    </span><span class="n">P</span><span class="p">(</span><span class="n">b1</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">V</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">S5</span><span class="p">(){</span>
<span class="w">    </span><span class="n">P</span><span class="p">(</span><span class="n">b2</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">V</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">S6</span><span class="p">(){</span>
<span class="w">    </span><span class="n">P</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="w">    </span><span class="n">P</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
<span class="w">    </span><span class="n">P</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div>

<p>另一角度：图论出度（P）入度（V）</p>
<p><strong>管程</strong></p>
<p>名称、共享结构数据、一组过程（函数）、设置共享结构数据初值</p>
<p>互斥特性由编译器负责实现</p>
<p>各外部进程/线程，只能从管程提供的特定入口才能访问共享数据</p>
<p>每次只允许一个进程在管程内执行某个内部过程</p>
<p><strong>经典同步问题</strong></p>
<p><em>1.生产者消费者问题</em></p>
<ul>
<li>
<p>一组生产者进程(Producer)</p>
</li>
<li>
<p>一组消费者进程(Consumer)</p>
</li>
<li>
<p>共享初始为空 大小为n的缓冲区(Buffer)</p>
</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="nv">semaphore</span><span class="w"> </span><span class="nv">mutex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="c1">;  //mutex</span>
<span class="nv">semaphore</span><span class="w"> </span><span class="nv">empty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">n</span><span class="c1">;  //buffer</span>
<span class="nv">semaphore</span><span class="w"> </span><span class="nv">full</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">;   //full</span>

<span class="nv">Producer</span><span class="ss">()</span>{
<span class="w">    </span><span class="k">while</span><span class="ss">(</span><span class="mi">1</span><span class="ss">)</span>{
<span class="w">        </span><span class="nv">Produce</span><span class="ss">()</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">P</span><span class="ss">(</span><span class="nv">mutex</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">add2Buffer</span><span class="ss">()</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">V</span><span class="ss">(</span><span class="nv">mutex</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">V</span><span class="ss">(</span><span class="nv">full</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span>}
}

<span class="nv">Consumer</span><span class="ss">()</span>{
<span class="w">    </span><span class="k">while</span><span class="ss">(</span><span class="mi">1</span><span class="ss">)</span>{
<span class="w">        </span><span class="nv">P</span><span class="ss">(</span><span class="nv">full</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">P</span><span class="ss">(</span><span class="nv">mutex</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">getFromBuffer</span><span class="ss">()</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">V</span><span class="ss">(</span><span class="nv">mutex</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">Consume</span><span class="ss">()</span><span class="c1">;</span>
<span class="w">    </span>}
}
</code></pre></div>

<p><em>2.读者写者问题</em></p>
<ul>
<li>读者进程(Reader)</li>
<li>写者进程(Writer)</li>
<li>共享一个文档(Document)</li>
<li>多进程读，不可多进程写</li>
<li>写进程写，不可读</li>
<li>写进程检查是否有读进程读</li>
</ul>
<p><strong>读进程优先</strong></p>
<div class="codehilite"><pre><span></span><code><span class="nv">int</span><span class="w"> </span><span class="nv">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">;</span>
<span class="nv">semaphore</span><span class="w"> </span><span class="nv">mutex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="c1">;</span>
<span class="nv">semaphore</span><span class="w"> </span><span class="nv">rw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="c1">;</span>
<span class="nv">Reader</span><span class="ss">()</span>{
<span class="w">    </span><span class="k">while</span><span class="ss">(</span><span class="mi">1</span><span class="ss">)</span>{
<span class="w">        </span><span class="nv">P</span><span class="ss">(</span><span class="nv">mutex</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="k">if</span><span class="ss">(</span><span class="nv">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="ss">)</span>
<span class="w">            </span><span class="nv">P</span><span class="ss">(</span><span class="nv">rw</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">count</span><span class="o">++</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">V</span><span class="ss">(</span><span class="nv">mutex</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">Read</span><span class="ss">()</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">P</span><span class="ss">(</span><span class="nv">mutex</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">count</span><span class="o">--</span><span class="c1">;</span>
<span class="w">        </span><span class="k">if</span><span class="ss">(</span><span class="nv">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="ss">)</span>
<span class="w">            </span><span class="nv">V</span><span class="ss">(</span><span class="nv">rw</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">V</span><span class="ss">(</span><span class="nv">mutex</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span>}
}
<span class="nv">Writer</span><span class="ss">()</span>{
<span class="w">    </span><span class="k">while</span><span class="ss">(</span><span class="mi">1</span><span class="ss">)</span>{
<span class="w">        </span><span class="nv">P</span><span class="ss">(</span><span class="nv">rw</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">write</span><span class="ss">()</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">v</span><span class="ss">(</span><span class="nv">rw</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span>}
}
</code></pre></div>

<p><strong>写进程优先</strong></p>
<div class="codehilite"><pre><span></span><code><span class="nv">int</span><span class="w"> </span><span class="nv">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">;</span>
<span class="nv">semaphore</span><span class="w"> </span><span class="nv">mutex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="c1">;</span>
<span class="nv">semaphore</span><span class="w"> </span><span class="nv">rw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="c1">;</span>
<span class="nv">semaphore</span><span class="w"> </span><span class="nv">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="c1">;</span>
<span class="nv">Writer</span><span class="ss">()</span>{
<span class="w">    </span><span class="k">while</span><span class="ss">(</span><span class="mi">1</span><span class="ss">)</span>{
<span class="w">        </span><span class="nv">P</span><span class="ss">(</span><span class="nv">w</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">P</span><span class="ss">(</span><span class="nv">rw</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">Write</span><span class="ss">()</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">V</span><span class="ss">(</span><span class="nv">rw</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">V</span><span class="ss">(</span><span class="nv">w</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span>}
}
<span class="nv">Reader</span><span class="ss">()</span>{
<span class="w">    </span><span class="k">while</span><span class="ss">(</span><span class="mi">1</span><span class="ss">)</span>{
<span class="w">        </span><span class="nv">P</span><span class="ss">(</span><span class="nv">w</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">P</span><span class="ss">(</span><span class="nv">mutex</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="k">if</span><span class="ss">(</span><span class="nv">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="ss">)</span>
<span class="w">            </span><span class="nv">P</span><span class="ss">(</span><span class="nv">rw</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">count</span><span class="o">++</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">V</span><span class="ss">(</span><span class="nv">mutex</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">V</span><span class="ss">(</span><span class="nv">w</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">Read</span><span class="ss">()</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">P</span><span class="ss">(</span><span class="nv">mutex</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">count</span><span class="o">--</span><span class="c1">;</span>
<span class="w">        </span><span class="k">if</span><span class="ss">(</span><span class="nv">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="ss">)</span>
<span class="w">            </span><span class="nv">V</span><span class="ss">(</span><span class="nv">rw</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">V</span><span class="ss">(</span><span class="nv">mutex</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span>}
}
</code></pre></div>

<p><em>3.哲学家进餐问题</em></p>
<ul>
<li>5名哲学家(Philosopher)</li>
<li>每两名之间有一根筷子(Chopstick)</li>
<li>每名有一碗饭</li>
<li>吃完饭思考</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="n">semaphore</span><span class="w"> </span><span class="n">Chopsticks</span><span class="o">[</span><span class="n">5</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="err">}</span><span class="p">;</span>
<span class="n">semaphore</span><span class="w"> </span><span class="n">mutex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">Philosopher</span><span class="p">()</span><span class="err">{</span>
<span class="w">    </span><span class="n">do</span><span class="err">{</span>
<span class="w">        </span><span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
<span class="w">        </span><span class="n">P</span><span class="p">(</span><span class="n">Chopsticks</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">        </span><span class="n">P</span><span class="p">(</span><span class="n">Chopsticks</span><span class="o">[</span><span class="n">(i+1)%5</span><span class="o">]</span><span class="p">);</span>
<span class="w">        </span><span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
<span class="w">        </span><span class="n">eat</span><span class="p">();</span>
<span class="w">        </span><span class="n">V</span><span class="p">(</span><span class="n">Chopsticks</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">        </span><span class="n">V</span><span class="p">(</span><span class="n">Chopsticks</span><span class="o">[</span><span class="n">(i+1)%5</span><span class="o">]</span><span class="p">);</span>
<span class="w">        </span><span class="n">think</span><span class="p">();</span>
<span class="w">    </span><span class="err">}</span>
<span class="err">}</span>
</code></pre></div>

<p><strong>4.吸烟者问题</strong></p>
<ul>
<li>3个吸烟者进程(Smoker)</li>
<li>1个提供者进程(Offer)</li>
<li>Smoker1(paper, glue)</li>
<li>Smoker2(tobacco, glue)</li>
<li>Smoker3(paper, tobacco)</li>
<li>Offer(offer1) return paper, glue</li>
<li>Offer(offer2) return tobacco, glue</li>
<li>Offer(offer3) return paper, tobacco</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="nv">int</span><span class="w"> </span><span class="nv">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">;    //store random num</span>
<span class="nv">semaphore</span><span class="w"> </span><span class="nv">offer1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">;</span>
<span class="nv">semaphore</span><span class="w"> </span><span class="nv">offer2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">;</span>
<span class="nv">semaphore</span><span class="w"> </span><span class="nv">offer3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">;</span>
<span class="nv">semaphore</span><span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">;</span>
<span class="nv">Offer</span><span class="ss">()</span>{
<span class="w">    </span><span class="nv">whlie</span><span class="ss">(</span><span class="mi">1</span><span class="ss">)</span>{
<span class="w">        </span><span class="nv">num</span><span class="o">++</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">num</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="c1">;</span>
<span class="w">        </span><span class="k">if</span><span class="ss">(</span><span class="nv">num</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="ss">)</span>
<span class="w">            </span><span class="nv">V</span><span class="ss">(</span><span class="nv">offer1</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="ss">(</span><span class="nv">num</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="ss">)</span>
<span class="w">            </span><span class="nv">V</span><span class="ss">(</span><span class="nv">offer2</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="nv">V</span><span class="ss">(</span><span class="nv">offer3</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">P</span><span class="ss">(</span><span class="k">end</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span>}
}
<span class="nv">Smoker1</span><span class="ss">()</span>{
<span class="w">    </span><span class="k">while</span><span class="ss">(</span><span class="mi">1</span><span class="ss">)</span>{
<span class="w">        </span><span class="nv">P</span><span class="ss">(</span><span class="nv">offer3</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">smoke</span><span class="ss">()</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">V</span><span class="ss">(</span><span class="k">end</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span>}
}
<span class="nv">Smoker2</span><span class="ss">()</span>{
<span class="w">    </span><span class="k">while</span><span class="ss">(</span><span class="mi">1</span><span class="ss">)</span>{
<span class="w">        </span><span class="nv">P</span><span class="ss">(</span><span class="nv">offer2</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">smoke</span><span class="ss">()</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">V</span><span class="ss">(</span><span class="k">end</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span>}
}
<span class="nv">Smoker3</span><span class="ss">()</span>{
<span class="w">    </span><span class="k">while</span><span class="ss">(</span><span class="mi">1</span><span class="ss">)</span>{
<span class="w">        </span><span class="nv">P</span><span class="ss">(</span><span class="nv">offer1</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">smoke</span><span class="ss">()</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">V</span><span class="ss">(</span><span class="k">end</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span>}
}
</code></pre></div>

<p><em>eg1</em></p>
<ul>
<li>3个进程P1 P2 P3</li>
<li>互斥使用N个单元的缓冲区(Buffer)</li>
<li>P1 produce() return (int num) put() @Buffer</li>
<li>P2 </li>
</ul>
<p><strong>死锁</strong></p>
<p>多个进程因竞争资源造成的一种互相等待，若无外力作用，这些进程都将无法向前推进</p>
<p>死锁产生的原因：（1）系统资源的竞争（2）进程推进顺序非法（3）死锁产生的必要条件：互斥条件、不剥夺条件（已经至少保持了一个资源）、请求并保持条件、循环等待条件</p>
<p><strong>发生死锁一定有循环等待，但发生循环等待未必死锁</strong></p>
<p><strong>死锁的处理策略</strong></p>
<p><strong>死锁预防</strong>：破坏四个必要条件之一即可</p>
<ul>
<li>
<p>破坏互斥条件</p>
</li>
<li>
<p>破坏不剥夺条件</p>
</li>
<li>
<p>破坏请求并保持条件</p>
</li>
<li>
<p>破坏循环等待条件</p>
</li>
</ul>
<p>死锁避免：在资源分配过程，防止进入不安全状态
- 银行家算法 </p>
<p>$$Need = Max -Allocation$$</p>
<p>死锁检测和解除：系统分配进程时不做措施，应该提供死锁检测和解除的手段</p>
<ul>
<li>资源分配图</li>
</ul>
<p><img alt="source_allocation" src="../images/source_allocation.png" /></p>
<p>请求边：从进程到资源
分配边：从资源到进程</p>
<ul>
<li>死锁定理：依次消除与不阻塞进程相连接的边，直到无边可消除</li>
<li>死锁解除：资源剥夺法、撤销进程法、进程回退法</li>
</ul>
<h1 id="_18">第三章 内存管理</h1>
<p><strong>程序装入和链接</strong></p>
<ul>
<li>编译：编译程序将源代码编译成若干目标模块</li>
<li>链接：链接程序将编译后形成一组目标模块及所需的库函数链接在一起，形成一个完整的装入模块</li>
<li>装入：装入程序装入模块装入内存运行</li>
</ul>
<p>链接方式</p>
<ul>
<li>静态：程序运行前，链接为一个完整可执行的程序</li>
<li>装入时动态：装入过程中，边装入边链接</li>
<li>运行时动态：程序执行过程需要该模块才进行</li>
</ul>
<p>装入方式：</p>
<ul>
<li>绝对装入：仅适用于单道程序，装入程序按照装入模块中的地址，将程序数据装入内存，逻辑地址与物理地址完全相同</li>
<li>可重定位装入（静态重定位）：一个作业装入内存，<strong>必须给它分配要求的全部内存空间</strong>，若没有足够的内存，则无法装入。一旦运行，作业进入内存，整个运行期间不能在内存中移动，也不能再申请内存空间</li>
<li>动态运行时装入（动态重定位）：程序在内存中发生移动，则需要采用动态的装入方式。装入程序把装入内存后，并不立即将装入模块中的相对地址转换为绝对地址，而是将<strong>地址转换推迟到程序真正要执行时才进行</strong>，需要重定位寄存器的支持</li>
</ul>
<p>逻辑地址和物理地址</p>
<ul>
<li>地址重定位：当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成为物理地址</li>
</ul>
<p>内存保护</p>
<ul>
<li>在CPU中设置一堆上、下限寄存器，CPU要访问一个地址，分别和两个寄存器值相比，判断有无越界</li>
<li>采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）来实现这种保护</li>
</ul>
<p><strong>连续分配管理方式</strong></p>
<p>单一连续分配</p>
<p>内存分为系统区、用户区，无需进行内存保护，内存中只允许有有一道程序</p>
<ul>
<li>优 简单无外部碎片</li>
<li>缺 只能用于单用户、单任务的操作系统中，有内部碎片，存储器利用率极低</li>
</ul>
<p><strong>固定分区分配</strong></p>
<p>将用户内存空间划分为若干固定大小的区域，每个分区只装入一道作业。当有空闲分区时，可从外存的后备作业队列中选择适当大小的作业装入</p>
<ul>
<li>划分分区方式：分区大小相等、分区大小不等</li>
</ul>
<p>问题</p>
<ul>
<li>程序可能太大放不进任何一块分区，用户不得不使用覆盖技术使用内存空间</li>
<li>主存利用率低，程序小也要占用一个分区，现象称为<strong>内部碎片</strong></li>
</ul>
<p><strong>动态分区分配</strong></p>
<p>又称可变分区分配，不预先划分内存，在进程装入内存时，根据进程大小动态地建立分区，并使分区的大小正好适合进程的需要</p>
<p>问题：所有分区外的存储空间会产生越来越多的碎片，克服外部碎片可以通过紧凑技术来解决</p>
<p>动态分区策略</p>
<ul>
<li>
<p>首次适应Fiist Fit：空闲分区以地址递增的次序链接，找到大小能满足要求的第一个空间。会使得内存的低地址部分出现很多小的空闲分区，每次分配查找时，都要经过这些分区，增加了查找的开销</p>
</li>
<li>
<p>最佳适应Best Fit：空闲分区按容量递增的方式形成分区链，找到第一个能满足要求的空间。性能通常很差，因为每次最佳的分配会留下很小难以利用的内存块，会产生最多的外部碎片。</p>
</li>
<li>
<p>最坏适应Worst Fit（最大适应Lasgest Fit）:以容量递减的次序链接，找到第一个能满足要求的空闲分区。选择最大的块，但却把最大的连续内存的划分开，会很快导致没有可用的大内存块，导致性能很差</p>
</li>
<li>
<p>邻近适用Next Fit（循环首次适应算法）：分配内存时从上次查询结束的位置开始继续查找。在一次扫描中，内存前面部分使用后再释放时，不会参与分配，导致在内存的末尾分配空间分裂为小碎片。</p>
</li>
</ul>
<p><strong><em>非连续分配</em></strong> </p>
<p><strong>基本分页存储管理方式</strong>：主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程以块为单位进行划分，进程在执行时，以块为单位逐个申请贮存中的空间</p>
<p>分页管理不会产生外部碎片，块的大小相对分区要小，进程按块划分，进程运行时按块申请主存可用空间并执行，进程只会在最后一个不完整的块，不产生主存碎片，，每个进程平均只产生半个块大小的内部碎片</p>
<ul>
<li>
<p>页面和页面大小：进程中的块称为页（page），内存中的块称为页框（page frame、或页帧）。外存也以同样的单位进行划分，称为块（block）。进程在执行时需要申请主存空间，要为每个页面分配主存中的可用页框，页和页框一一对应</p>
</li>
<li>
<p>地址结构</p>
</li>
</ul>
<p><img alt="single_page" src="../images/single_page.png" /></p>
<ul>
<li>页表：通过查找页表即可找到相应的物理块</li>
</ul>
<p>基本地址变换：</p>
<p>将逻辑地址变换为内存中的物理地址，在系统中设置页表寄存器（PTR）存放内存起始地址F和页表长度M。</p>
<p><img alt="page_allocation_transform" src="../images/page_allocation_transform.png" /></p>
<p>$$
&amp;（1）页号P=\frac{A}{L}\
&amp;（2）页内偏移量W=A\%L\
&amp;（3）比较页号P和页表长度M，P\geq M产生越界中断\
&amp;（4）页表中页号P对应的页表项地址A=F+P<em>M\
&amp;（5）物理地址E=b</em>L+W\
$$
<em>页式管理中空间地址是一维的</em></p>
<p>问题
- 每次访存均需地址变换，地址变换必须足够快，否则访存速度会降低
- 每个进程引入页表，用于存储映射机制，页表不能过大</p>
<p>引入快表机制：在地址变换过程中加入具有并行查找能力的高速缓冲存储器——<strong>快表</strong>（相联存储器TLB，主存中的页表为<strong>慢表</strong>）</p>
<p><img alt="add_TLB_page_allocation_transform" src="../images/add_TLB_page_allocation_transform.png" /></p>
<p>一次地址变换流程</p>
<p>（1）CPU给出逻辑地址，将页号送入高速缓冲寄存器，查询此页号是否存在于快表内</p>
<p>（2）若匹配到，直接取出对应页的页框号，与页内偏移拼接为物理地址，访存</p>
<p>（3）若未匹配到，访问慢表查询，读取页表项后复制到快表中，进行地址变换后访存</p>
<p><em>值得注意的是，题中是否说明快表初始为空以及快表慢表的查询机制，是否同时查询！</em></p>
<p>两级页表</p>
<ul>
<li>引入页表，执行时不需要调入所有内存页框，为了压缩页表，采取多级映射</li>
</ul>
<p><img alt="2_dim_page" src="../images/2_dim_page.png" /></p>
<ul>
<li>多级页表大小不能超过一个页面</li>
</ul>
<p><img alt="2_dim_page_arch" src="../images/2_dim_page_arch.png" /></p>
<p>$$
&amp;逻辑地址：32bit\
&amp;以字节编址\
&amp;页表项：4B\
&amp;页面大小：4KB=2^{12}B （页内偏移量）\
&amp;页号：32-12=20\
&amp;全映射需要2^{20}个页表项\
&amp;共需4B<em>2^{20}=4MB大小空间存储页表\
&amp;\
&amp;以40MB进程为例\
&amp;页表项：\frac{40MB}{4B</em>4KB}=40KB\
&amp;需要\frac{40KB}{4KB}=10页面\
&amp;整个进程需要\frac{40MB}{4KB}=10<em>2^{10}个页面\
&amp;\
&amp;为了压缩页表，采取二级页表机制\
&amp;页表10页进行映射只需要10个页表项\
&amp;上一级页表只需要1页就已经足够2^{10}=1024个页表项\
&amp;进程执行时，仅需将这一页的上级页表调入即可\
&amp;页面大小：4KB=2^{12}B （页内偏移量）\
&amp;页号：32-12=20\
&amp;顶级（一级）页表为1个页面\
&amp;一级页表项\frac{4KB}{4B}=1K\
&amp;一级页表占用log_2{1K}=10位\
&amp;二级页表占用20-10=10位\
&amp;二级页表大小2^{10}</em>4B=4KB\leq页面大小4KB\
$$</p>
<p><strong>基本分段存储管理方式</strong></p>
<p>分页管理是从计算机角度考虑设计，提高内存利用率，分页通过硬件机制实现</p>
<p>分段管理是从用户和程序员出发，方便编程、信息保护和共享、动态增长以及动态链接等方面的需要</p>
<p><img alt="single_seg" src="../images/single_seg.png" /></p>
<p>段号决定每个进程最多可以分几个段，段内地址决定每个段内的最大长度</p>
<p>段表：每个进程都有一张逻辑空间与内存空间映射的段表</p>
<p><img alt="seg" src="../images/seg.png" /></p>
<p>地址变换机构</p>
<p><img alt="分段地址变换机构" src="../images/segment_address_translation_mechanism.png" /></p>
<p>$$
&amp;从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W\
&amp;比较段号S和段表长度M，S\geq M,产生越界中断，否则继续执行\
&amp;段表中段号S对应段表项地址=段表始址F+段号S*段表项长度\
&amp;段内偏移量\geq C，产生越界中断，否则继续执行\
&amp;取出段表项中该段的起始地址b，E=b+W，得到物理地址E去访问内存\
$$</p>
<p>段的共享与保护：分段系统，通过两个作业的段表中相应表项指向被共享的段同一个物理副本，当地一个作业从共享段读取数据，必须防止另一个修改数据，不能修改的的代码称为<strong>纯代码、可重入代码</strong></p>
<p>段号和段内偏移需要显示给出，地址空间为二维</p>
<p><strong>段页式管理方式</strong></p>
<p>作业的地址空间被分为若干逻辑段，每段都有自己的段号，将每段分为若干大小的固定的页，内存空间分为若干和页面大小相同的存储块，对内存的分配以块为单位。</p>
<ul>
<li>
<p>段号位数决定每个进程最多可以分几个段</p>
</li>
<li>
<p>页号位数决定最多有几个页</p>
</li>
<li>
<p>页内偏移量决定页面大小、内存块的大小</p>
</li>
</ul>
<p>段页式系统的逻辑地址结构：</p>
<p><img alt="OS_page_seg_add" src="../images/OS_page_seg_add.png" /></p>
<p>地址变换</p>
<p>需要三次访存，可以使用快表机制</p>
<p><img alt="segment_page_address_translation_mechanism" src="../images/segment_page_address_translation_mechanism.png" /></p>
<p><strong>虚拟内存管理</strong></p>
<p>传统存储管理方式</p>
<ul>
<li>一次性：一次全部装入，才能开始</li>
<li>驻留性：装入后，常驻内存，任何部分都不会被换出，直至结束</li>
</ul>
<p>局部性原理</p>
<p>一个程序，一段时间内，只有一部分会被访问</p>
<ul>
<li>空间</li>
<li>时间</li>
</ul>
<p>虚拟存储器</p>
<p>将程序的一部分装入内存，其余部分留在外存，当所访问的部分不在内存，操作系统将需要的部分调入内存，将暂时不需要的内容换到外存</p>
<ul>
<li>多次性：无需一次全部装入，允许分为多次调入</li>
<li>对换性：无需常驻内存</li>
<li>虚拟性：从逻辑上扩充内存容量，使用户看到的内存容量远大于内存容量</li>
</ul>
<p>本质：用时间换空间</p>
<p>实现：请求分页、请求分段、请求段页式</p>
<p>支持：内存、外存、页表机制、段表机制、中断机构、地址变换机构</p>
<p><strong>请求分页管理方式</strong></p>
<p>访问不存在内存中的页面，通过调页将其调入，通过置换算法将暂时不需要的页面调到外存上</p>
<p>页表机制</p>
<p><img alt="Request_paging_page_table_mechanism" src="../images/Request_paging_page_table_mechanism.png" /></p>
<p>$$
&amp;状态位P：指示是否调入内存\
&amp;访问字段A：记录一段时间内被访问的次数\
&amp;修改位M：标识页面调入内存后是否被修改过\
&amp;外存地址：指出该页在外存上的地址，通常是物理块号\
$$</p>
<p>缺页中断机制</p>
<p>访问页面不在内存中时，产生一个缺页中断，请求操作系统将缺页调入内存，将缺页的进程阻塞，若内存有闲置的空闲块，则分配一个块，将页面装入，并修改页表相应的页表项，若内存中无空闲块，则淘汰某页，淘汰页若在内存中修改过需要同步，写回外存</p>
<p>地址变换机构</p>
<p><img alt="request_paging_address_translation_mechanism" src="../images/request_paging_address_translation_mechanism.png" /></p>
<p>页面置换算法</p>
<ul>
<li>最佳置换算法OPT</li>
</ul>
<p>选择的被淘汰页是以后永不使用的页面，或是最长时间内不再被访问的页面</p>
<ul>
<li>先进先出算法FIFO</li>
</ul>
<p>优先淘汰最早进入内存的页面，即内存中驻留时间最久的页面</p>
<p>会产生所分配的物理块增大页故障数不减反增的异常现象，<strong>Belady异常</strong></p>
<ul>
<li>最近最久未使用算法LRU</li>
</ul>
<p>选择最近最长时间未访问过的页面予以淘汰，为每个页面设置一个访问字段记录上次被访问所经历的时间</p>
<p>性能较好，需要寄存器和栈的硬件支持</p>
<ul>
<li>时钟置换算法CLOCK</li>
</ul>
<p>简单的CLOCK算法：每帧关联一个附加位，使用位<strong>u</strong>，连成一个循环队列。某页装入时，使用位置为1；被访问时，使用位置为1；置换时，操作系统扫描缓冲区，每当遇到一个使用位为1的帧，置为0；最后停留在第一个使用位为0的帧</p>
<p>CLOCK算法性能比较接近LRU算法</p>
<p>改进的CLOCK算法：再增加一个修改位<strong>m</strong>，<strong>P(u,m)</strong></p>
<p>第一轮扫描，指针扫描过的页面使用位<strong>u</strong>置为0</p>
<p>第一轮扫描中，未找到使用位<strong>u</strong>为0的页面进行第二轮扫描</p>
<p>第二轮扫描，第一个页面置换出，换入页面<strong>m</strong>修改位置为1，并将指针后移</p>
<p><strong>页面分配策略</strong></p>
<p>一个进程分配的物理页框的集合，分配给一个进程的存储量越小，任何时候驻留在主存中的进程数就越多，从而提高处理机的效率；一个进程页数过少，基于局部性原理，页错误率会相对较高；页数过多，基于局部性原理，给特定的进程分配更多主存空间对该进程的错误率没有明显改善。</p>
<p>策略：固定分配局部置换、可变分配全局置换、可变分配局部置换（没有固定分配全局分配）</p>
<p>调入时机：预调页策略、请求调页策略</p>
<p>从何处调页：系统拥有足够的对换区间、系统缺少足够的对换区间、UNIX方式</p>
<p><strong>抖动</strong></p>
<p>某进程频繁访问的页面数目高于可用的物理页帧数目</p>
<p><strong>工作集</strong></p>
<p>在某段时间间隔内，进程要访问的页面集合</p>
<p>一般，分配给进程的物理块数（驻留集大小）要大于工作集大小</p>
<h1 id="_19">第四章 文件系统</h1>
<p><strong>文件</strong></p>
<p>文件结构：数据项、记录、文件</p>
<p>属性：名称、标识符、类型、位置、大小、保护、时间</p>
<p>所有文件的信息都保存在目录结构中，而目录结构保存在外存上，文件信息在需要时调入内存。</p>
<p>基本操作：创建、写、读、重定位、删除、截断</p>
<p>文件逻辑结构</p>
<ul>
<li>无结构文件（流式文件）</li>
</ul>
<p>二进制式字符流组成</p>
<ul>
<li>有结构文件（记录式文件）</li>
</ul>
<p>顺序文件</p>
<p>索引文件</p>
<p>索引顺序文件</p>
<p>直接文件或散列文件</p>
<p><strong>目录结构</strong></p>
        </section>
    </div>
</body>

</html>